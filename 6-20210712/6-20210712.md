# day6

## STM32的开发

1. 寄存器
2. std库
3. HAL库

今天主要任务：用不同的方式点亮LED

注：

    1. 因为STM32G0引脚比较少
    2. STM32G0没有预留JTAG的口，如需要使用JTAG需要手动连杜邦线
    3. 如果使用串口下载方式，个人认为比较繁琐
    - 因为有STM32F1开发板，所以将单片机型号改为STM32F103RCT6.大部分代码相同，逻辑上全部类似；可以使用JTAG，方便程序调试。

### STM32寄存器开发方法

#### 认识寄存器

##### 什么是寄存器？

在数字电子，尤其是计算中，硬件寄存器是通常由触发器组成的电路，通常具有许多类似于存储器的特性，例如：

- 一次读取或写入多个位的能力
- 使用地址以类似于内存地址的方式选择特定寄存器

然而，它们的显着特点是它们还具有超出普通内存的特殊硬件相关功能。所以，从不同的角度来看，硬件寄存器就像内存，具有额外的硬件相关功能；或者，内存电路就像只存储数据的硬件寄存器。

硬件寄存器用于软件和外设之间的接口。软件写入它们以向设备发送信息，并读取它们以从设备获取信息。一些硬件设备还包括软件不可见的寄存器，供其内部使用。

> 详见《微机原理与接口技术》

##### 如何寻找 STM32F103RCT6 的寄存器


![](assets/markdown-img-paste-20210712193750670.png)

![](assets/markdown-img-paste-2021071219410024.png)

![](assets/markdown-img-paste-2021071219402132.png)

![](assets/markdown-img-paste-2021071219432971.png)

![](assets/markdown-img-paste-20210712194921717.png)

![](assets/markdown-img-paste-2021071219510933.png)

（P194）

![](assets/markdown-img-paste-20210712194747258.png)

并不觉得像STM32这类功能强大的单片机应当用寄存器的方式来开发。

以上课时用STM32G0编写的一段代码来解释。

```C
#include <stm32g0xx.h>  //这里存入了寄存器的定义表
/*USER Define-----------------------------*/
#define MY_MODE_OUTPUT_PP	0
#define MY_MODE_OUTPUT_OD 	1
#define MY_SPEED_LOW 		0
#define MY_SLEED_MID 		1
#define MY_SPEED_HIGH 		2
#define MY_SPEED_VERY_HIGH 	3
/*Define End------------------------------*/

//用户自己定义结构体，方便后续输入
typedef struct {
    uint16_t pin;
    uint8_t DirOrSpeed;//输入还是输出，速度
    uint8_t PP_OD_Pull;//输出模式
} myGPIO_ST;

//延时函数
void delay(unsigned int a) {
    while(a--) {
        ;
    }
}

void IO_Init(GPIO_TypeDef *GPIOx,myGPIO_ST* st) {
    uint8_t temp;
    if (st->DirOrSpeed > 0) { //不是输入模式。暂时只处理输出
        GPIOx->ODR &= ~(0xf << st->pin*4);
        temp =(st->PP_OD_Pull<<2)|(st->DirOrSpeed);
        GPIOx ->ODR |= temp << (st->pin*4);
    }
}

int main() {

    RCC->IOPENR |= RCC_IOPENR_GPIOBEN;
    myGPIO_ST myGPIO;
    myGPIO.pin = 0;
    myGPIO.DirOrSpeed = MY_SPEED_LOW;
    myGPIO.PP_OD_Pull = MY_MODE_OUTPUT_PP;

    IO_Init(GPIOB,&myGPIO);

    while(1) {
        GPIOB->ODR &= ~(0x1<<(0*1) | (1*1));
        delay(0xfffff);
        GPIOB->ODR |= (0x1<<(0*1) | (1*1));
        delay(0xfffff);
    }
}
```

与之前接触过的std库函数相比，无论从可读性还是开发的速度和对开发者的要求上，库函数开发都略胜寄存器开发一筹。


### HAL库


![](assets/markdown-img-paste-20210712200253637.png)

STM32Cube硬件抽象层（HAL），STM32抽象层嵌入式软件，可确保STM32微控制器上最大的可移植性。 HAL适用于所有硬件外围设备。他们隐藏MCU和外设复杂度到最终用户。

#### 从寄存器到HAL库

寄存器操作让我想起刚接触单片机时，我开始使用<u>MSP430</u>的寄存器开发的方式，代码可读性比较差（即便当时写了简单的注释，现在读起来也比较吃力）；唯一的好处是让我对指针有了进一步的了解。

- *其实《微机原理》解释得还蛮清楚的*


![](assets/markdown-img-paste-20210712200702834.png)
